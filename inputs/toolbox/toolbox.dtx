% \def\fileversion{3.2}\def\filedate{2001/05/08}\def\docdate{2001/05/08}
%\iffalse These lines are necessary for the doc and docstrip utilities
%<*asciidocu>

%%#
%%# Author:
%%#
%%# M. V\"ath      vaeth@mathematik.uni-wuerzburg.de
%%#

%%#############################################################################
%%#
%%#  The TeX programmer's toolbox; enhanced version.
%%#  This (La)TeX package provides some macros which are convenient for
%%#  writing indices, glossaries, or other macros.
%%#  It contains macros which support
%%#
%%#    - implicit macros - a useful supplement to \index or varindex for
%%#      writing glossaries or indices
%%#    - fancy optional arguments
%%#    - loops over tokenlists and itemlists
%%#    - searching and splitting
%%#    - controlled expansion
%%#    - redefinition of macros
%%#    - concatenated macro names
%%#
%%#############################################################################

%%#
%%# This package was tested with plain TeX, LaTeX 2.09, and LaTeX 2e,
%%# and it should actually run with all TeX formats.
%%#

% If you have access to (reasonable new) docstrip TeXfiles, you should run
% tex/latex on the file
%   `toolbox.ins'
% to produce the files `toolbox.sty', `toolbox.txt' and `toolbox.tex'.
% (In case `toolbox.ins' is lost: You can find its content in the last
%  few lines of the file you are currently reading between the
%  lines %<*insfile> and %</insfile>;
%  BTW: You should name this file here `toolbox.dtx' before you run tex
%  on toolbox.ins).
%
% The file `toolbox.txt' contains a `brief' (but complete) ascii
% documentation. If you have additionally access to LaTeX 2e, you may run
% latex on the generated file `toolbox.tex' to produce `toolbox.dvi' which
% contains a more luxury documentation.
%
% If you do not have access to the docstrip TeXfiles you may simply
% copy/rename this file here into
%   `toolbox.sty'
% to use the package and read the ascii documentation in this file.
% The ascii documentation (the content of `toolbox.txt') consists of all
% lines in this file which start with %%# (this is the above block and another
% (very large) block which follows soon).
%
% But I do not recommended this, because TeX will need more time to read this
% longer file, and because there might be a (very slight) incompatibility if
% you use it (namely if you load `toolbox.sty' with some *extremely* strange
% catcodes).
% I recommend in this case instead to generate the file `toolbox.sty' as
% anything between the lines %<*package> and %</package> by hand.
% (This is not precisely the file which you get with the docstrip TeXfiles,
% but a reasonable good substitute. To speed up loading, you may also
% eliminate all lines starting with `% ' in `toolbox.sty').
% For your information: The file `toolbox.tex' produced by the docstrip
% TeXfiles is anything between the lines %<*driver> and %</driver>
% (with a line containing \endinput and two comment lines appended)
%
%
% In any case, you end up with the file `toolbox.sty'.
%
% If you can generate `toolbox.tex', you will probably want to stop
% reading now and instead read the `luxury' documentation in `toolbox.dvi'.
%
% Otherwise, you have to make due with the following ascii documentation.
%
%
% \fi\catcode\#14\relax\iffalse  (This line is needed for the doc utility)
%

%%# To use toolbox, you have to put `toolbox.sty' in a path where TeX looks
%%# for its input files. The TeX documents using toolbox need the
%%# following modifications in their header:
%%#
%%# a) If you use LaTeX2.09, use toolbox as a style option, e.g.
%%#      \documentstyle[toolbox]{article}
%%#    or
%%#      \documentstyle[toolbox,12pt]{article}
%%# b) If you use LaTeX2e, put in the preamble the command
%%#      \usepackage{toolbox}
%%# c) If you use some other (non-LaTeX) format, you will probably have to
%%#    insert a line like
%%#          \catcode`\@=11\input toolbox.sty\catcode`\@=12\relax
%%#
%%# The only LaTeX-specific commands used in `toolbox.sty' are:
%%#
%%#   \newcommand (only in the form \newcommand{\command}{} to ensure that
%%#                 \command was not defined before)
%%#   \ProvidesPackage
%%#   \typeout
%%#
%%#   The above commands are used only if they are defined.
%%#

%%#
%%# Description of the provided macros:
%%#

%%# General remark: Many macros could appear in several sections.
%%# For example, \toolboxMakeDef and \toolboxSourround might be considered
%%# as macros which support redefinitions of macros. However, we put them
%%# in different sections which perhaps explain better their nature.

%%#
%%# Implicit macro definitions
%%# --------------------------

%%# What we mean by implicit macro definitions is probably best explained by
%%# the following examples which show the intended usage:
%%#
%%# (In the following examples, we always refer to the \index command. Note
%%# that it may be more convenient to use for indices the varindex package in
%%# addition - the documentation of varindex (release 2.3 or newer) gives
%%# additional hints and examples how these two (essentially independent)
%%# approaches can be combined in practice).
%%#
%%# Assume that you want to write an index for a book which has rather
%%# long and complicated \index entries. The first idea that one might have in
%%# this connection is to put the various \index commands at the beginning of
%%# the document into several macros (one for each \index entry), and to use
%%# just these macros in the main text. For example, one might want to write
%%# near the beginning of the document commands like
%%#   \newcommand{\Start}{\index{finish or end}}
%%#   \newcommand{\End}{\index{finish or end}}
%%# and then to use in the main text \Start and \End whenever a reference
%%# in the corresponding index to the current place is desired.
%%# However, this has two major disadvantages:
%%#  1. Unless you are very disciplinary with your macro names, it is easy to
%%#     forget that \End writes an index entry. So the \End in the main text
%%#     might be very confusing.
%%#  2. You cannot choose short and intuitive macro names for common phrases,
%%#     because they are usually already reserved by TeX, LaTeX, or some
%%#     packages.
%%#
%%# To avoid these problems, one may be very disciplinary and call the
%%# involved macros systematically e.g. \GlossaryStart \GlossaryEnd etc.
%%# However, this produces terrible long and unreadable macro names in the
%%# main text.
%%#
%%# The implicit macro definitions of "toolbox" provide a more convenient
%%# solution. The idea is that you do not use the corresponding macros directly
%%# but only implicitly by a call of other macros where your "macro name" is
%%# just an argument.
%%# Moreover, "toolbox" assists you in writing the corresponding definitions.
%%# For example, if you know that you want a set of macros which all expand
%%# into something of the form \index{...}, you can give a ``mask'' which
%%# contains this form, and you only have to fill in the changing content
%%# (similarly as for usual TeX macros with arguments, but the level of
%%# abstraction is one step higher).
%%# For the above task, you might use the command:
%%#
%%#    \toolboxMakeDef{Glossary}{\index{#1}}
%%#
%%# The argument `Glossary' serves to distinguish independent definitions
%%# (this will become clear later). Its effect visible now is that it
%%# determines the name of the following macros which you can use after
%%# the above call:
%%#
%%#    \NewGlossary{start-1}{start}
%%#    \NewGlossary{start-2}{start or beginning}
%%#    \NewGlossary{end}{finish or end}
%%#
%%# These command are now similar to the \newcommand definitions explained
%%# above. However, there is no name collision with the TeX-internal command
%%# \end. Of course, this means that you cannot just write \end in the main
%%# text to get the desired index entry. Instead, you have to write the more
%%# intuitive commands
%%#
%%#    \Glossary{start-1}
%%#    \Glossary{start-2}
%%#    \Glossary{end}
%%#
%%# (again, the name \Glossary stems from our first call of \toolboxMakeDef).
%%# Note that e.g. \Glossary{start-1} expands not only to `start' but
%%# actually to \index{start} (because of our first call of \toolboxMakeDef).
%%# Note also that you can use symbols like - or numbers which are usually
%%# not allowed in TeX macro names.
%%#
%%# Of course, similarly as for \newcommand, you can also do other things with
%%# the macros. For example,
%%#
%%#    \LetGlossary\tempname{end}
%%#    \NewGlossary*{finish}\tempname
%%#
%%# will first define \tempname to expand to the same text as \Glossary{end},
%%# and then defines a new entry \Glossary{finish} to expand to the same text
%%# as \tempname. Hence, the above new lines make the calls \Glossary{end} and
%%# \Glossary{finish} equivalent.
%%#
%%# At the end of your list of \NewGlossary commands, you might want to put
%%#
%%#    \toolboxFreeDef*{Glossary}
%%#
%%# The purpose of this command is that \NewGlossary cannot be used anymore
%%# (unless, of course, you define it again). So you cannot unintentionally
%%# add new entries to your glossary list (but you still can use \Glossary{...}
%%# to reference to the already produced entries).
%%# Moreover, the above command frees some memory which was needed for
%%# \NewGlossary to work.
%%#
%%# If you additionally want to free the memory used by \Glossary, you can use
%%#
%%#    \toolboxFreeDef{Glossary}
%%#
%%# (without the `*'). This may be necessary, if you want to call again e.g.
%%#
%%#    \toolboxMakeDef{Glossary}{\emph{#1}\index{#1}}
%%#
%%# (if you have not freed the memory for \Glossary before this repeated call,
%%# TeX will complain that \Glossary is already defined).
%%#
%%# Of course, it is possible to call \toolboxMakeDef with several different
%%# names, for example, for \Glossary, \SymbolList etc. Another application
%%# might be to use a different command to mark e.\,g.\ the main occurrence of
%%# some index entry or to output additionally the entry into the running text.
%%# We do this in the following example which simultaneously
%%# demonstrates that the names can also be constructed in another way:
%%#
%%#   \toolboxMakeDef[Ind]{}{\index{#1}}
%%#   \toolboxMakeDef[Ind]{Main}{\index{#1|textbf}}
%%#   \toolboxMakeDef{OutInd}{#1}
%%#
%%#   \IndNew{A}{A is a letter}
%%#   \IndNewMain{A}{A is a letter}
%%#   \NewOutInd{A}{\textbf{The letter A}\Ind{A}}
%%#
%%# After the above commands, you can use \Ind{A}, \IndMain{A}, and
%%# \OutInd{A} to produce the corresponding \index entry, the "main" \index
%%# entry (with a boldface page number), and the text \textbf{The letter A}
%%# with an additional entry into the index, respectively.
%%# Of course, it might usually be more convenient to define the \Ind and
%%# \IndMain" entries simultaneously, e.g. as follows
%%#
%%#    \toolboxMakeDef[Ind]{}{#1}
%%#    \toolboxMakeDef[Ind]{Main}{#1}
%%#    \newcommand{\NewStandardInd}[2]{%
%%#       \IndNew{#1}{\index{#2}}%
%%#       \IndNewMain{#1}{\index{#2|textbf}}}
%%#
%%#    \NewStandardInd{A}{A is a letter}
%%#
%%# This approach has the additional advantage that you can define exceptional
%%# cases "by hand" (e.g. if you want that for certain "main" index
%%# entries the page number is printed with "\textsl" instead of "\textbf").


%%# Since the motivation for implicit definitions now is hopefully clear,
%%# let us now describe in detail which commands are provided by "toolbox".
%%# As explained in the example, the main generic macro provided to this
%%# purpose is \toolboxMakeDef. Its call syntax is as follows:
%%#
%%# \toolboxMakeDef[Prefix]{Name}{ReplacementMask}
%%#
%%# (the argument [Prefix] is optional and by default empty).
%%# The above command generates new macros
%%#
%%# \PrefixNewName
%%# \PrefixRenewName
%%# \PrefixProvideName
%%# \PrefixLetName
%%# \PrefixName
%%#
%%# which in turn can be called as follows
%%#
%%# \PrefixNewName{something}{RememberText}
%%# \PrefixRenewName{something}{RememberText}
%%# \PrefixProvideName{something}{RememberText}
%%# \PrefixNewName*{something}{\SomeMacro}
%%# \PrefixRenewName*{something}{\SomeMacro}
%%# \PrefixProvideName*{something}{\SomeMacro}
%%# \PrefixLetName{\SomeMacro}{something}
%%# \PrefixName{something}
%%# \PrefixName*{something}
%%#
%%# These calls are in a sense similar to the respective commands
%%#
%%# \newcommand{\something}{RememberText}
%%# \renewcommand{\something}{RememberText}
%%# \providecommand{\something}{RememberText}
%%# \newcommand{\something}{}\let\something\SomeMacro
%%# \renewcommand{\something}{}\let\something\SomeMacro
%%# \let\something\SomeMacro
%%# \let\SomeMacro{\something}
%%# \something
%%# \something (but without error if \something is undefined).
%%#
%%# with the differences already pointed out before:
%%# 1. The macro name actually used is not \something. Instead, it is a name
%%#    which does not conflict with any existing macro (except one
%%#    generated previously by another \PrefixNewName, but in this case a
%%#    descriptive error is output). For this reason, it is not possible to
%%#    use this macro directly but only indirectly by the call
%%#    \PrefixName{something} (or with \PrefixLetName).
%%# 2. The replacement text is not `RememberText' but determined by
%%#    ReplacementMask where every occurrence of #1 in ReplacementMask is
%%#    replaced by RememberText (recall the examples). If you want to have the
%%#    plain RememberText, use {#1} as ReplacementMask.
%%#
%%# \toolboxMakeDef gives an error message if the commands
%%# \Prefix... are already defined. If you intentionally want to
%%# change a previous definition, you have to call the command
%%#
%%#    \toolboxFreeDef[Prefix]{Name}
%%#
%%# before. The latter not only lets all of the macros \Prefix... be
%%# \undefined, but also frees all other memory internally used by the
%%# corresponding call of \toolboxMakeDef
%%# (note, however, that the above command does not free the
%%# memory allocated before by calls of \PrefixNew... - to free the latter,
%%# you have to call subsequently e.g.
%%#
%%#    \PrefixNewName*{...}{\undefined}
%%#
%%% before). There is also the command
%%#
%%#    \toolboxFreeDef*[Prefix]{Name}
%%#
%%# which acts similarly as \toolboxFreeDef but which does not undefine the
%%# two macros \PrefixName and \PrefixLetName.
%%#


%%#
%%# Fancy optional argument parsing
%%# -------------------------------

%%# \toolboxFuturelet\token{argument}
%%#
%%# The call \toolboxFuturelet\token{\command} has precisely the same effect as
%%# \futurelet\token\command. The advantage of \toolboxFuturelet is that
%%# instead of a single \command one may use also a sequence of commands
%%# (which may take arguments).

%%# \toolboxGobbleNext{cmd}
%%#
%%# This erases the token following that command from the token stream and
%%# then executes cmd. This is similar to
%%#   \def\toolboxGobbleNext#1#2{#1}
%%# with the difference that #2 is considered as a token and that no spaces
%%# are eaten.
%%# Example:
%%#  \toolboxGobbleNext{\foo}{{arg}
%%# is the same as \foo{arg}

%%# \toolboxIfNextToken{token}{IfPart}{ElsePart}
%%#
%%# If the token following this command is `token', then IfPart is executed,
%%# otherwise ElsePart. It is explicitly admissible that `token' is a space.
%%# In contrast to the corresponding LaTeX2e macros much care has been taken
%%# that spaces are not eaten. In particular, it is possible
%%# with this macro to define an optional argument at the end.
%%# To support further tests, \toolboxToken is \let to the token which follows
%%# the command. \toolboxToken is only a temporary token, i.e.
%%# it may also be modified by other commands of this package; in particular,
%%# it is also allowed to modify \toolboxToken.
%%# The token \toolboxSpaceToken which is described later may be handy
%%# in connection with this command.
%%#
%%# Example:
%%#
%%# \def\mycmd#1{\toolboxIfNextToken[{\ParseOpt{#1}}{\NoOpt{#1}}}
%%#    \def\ParseOpt#1[#2]{\OptAtEnd{#1}{#2}}
%%#
%%# After the above definition, \mycmd{arg} executes \NoOpt{arg} while
%%# \mycmd{arg}[optional]  executes \OptAtEnd{arg}{optional}
%%# We point out once more that in the first call a space following
%%# \mycmd{arg} does not vanish (as would be the case if the LaTeX 2e macros
%%# would have been used).

%%# \toolboxIfNextGobbling{token}{IfPart}{ElsePart}
%%#
%%# This command is analogous to \toolboxIfNextToken with the difference that
%%# in the case that the next token is the desired token, it is gobbled before
%%# IfPart is executed.
%%#
%%# Example:
%%#
%%# \def\myloop{\toolboxIfNextGobbling*\toolboxTokenLoop\toolboxLoop}
%%#
%%# This makes \myloop*... behave like \toolboxTokenLoop, and
%%# \myloop... (without *) behave like \toolboxLoop.

%%#
%%# Loops over tokenlists and itemlists
%%# -----------------------------------

%%# \toolboxLoop{items}{\action}
%%#
%%# This calls iteratively \action{#1}, where #1 runs over each item in the
%%# argument items. Here, an item is either a token or a group braced by {...}.
%%# In the latter case, the braces are lost. Spaces in items are ignored
%%# (unless they are braced). It is admissible that \action is not a single
%%# macro but instead a sequence of tokens.

%%# \toolboxLoop is not reentrant. To enable independent or recursive
%%# calls, the command
%%#
%%# \toolboxLoopName{name}{items}{\action}
%%#
%%# is provided which is analogous to \toolboxLoop and also not reentrant.
%%# But in contrast to \toolboxLoop, calls with different `name' arguments can
%%# be used independently of each other. In particular, using a counter in
%%# `name' one could easily implement even recursive calls. In this connection,
%%# it should be noted that `name' is expanded via \csname ... \endcsname, and
%%# so you may use constructs like \the\namecounter there.

%%# \toolboxTokenLoop{tokens}{\action}
%%#
%%# This is similar to \toolboxLoop: The command \action\toolboxToken
%%# is executed iteratively where \toolboxToken runs over each token in tokens.
%%# The important difference is that \toolboxToken is a token (instead of an
%%# item). In particular, \toolboxToken runs through every single token
%%# including spaces and braces.
%%# The token \toolboxSpaceToken which is described later may be handy
%%# in connection with this command.

%%# \toolboxTokenLoop is not reentrant. Analogously to \toolboxLoopName,
%%# independent versions can be generated by
%%#
%%# \toolboxTokenName{name}{tokens}{\action}

%%#
%%# Controlled expansion
%%# --------------------

%%# \toolboxDef\macrotodefine{argumentlist}
%%#
%%# This call is similar to
%%#    \def\macrotodefine{argumentlist}
%%# with two important differences:
%%#
%%# For \toolboxDef, the argumentlist is expanded precisely by one level.
%%# argumentlist may not contain macros with parameters.
%%# highest level are ignored. If you want to force a space on a particular
%%# place, use the macro \toolboxSpace at this place
%%# (which is described later).
%%#
%%# Example of usage:
%%#    \toolboxDef\chain{\chain\toolboxSpace\after}
%%# This modifies the macro \chain such that a space and the content of the
%%# macro \after is appended at the end.

%%# \toolboxAppend\macrotodefine{arglist}
%%#
%%# This is equivalent to \toolboxDef\macrotodefine{\macrotodefine arglist}
%%#

%%# \toolboxSurround{ContentBefore}{ContentAfter}\macro
%%#
%%# This redefines \macro such that ContentBefore is put at the beginning
%%# and ContentAfter after the definition of \macro. So this is equivalent to
%%# \def\macro{ContentBefore * ContentAFter}
%%# where * is the old content of \macro.
%%# The order of the arguments may appear strange, but it is convenient if
%%# ContentBefore or ContentAfter are macros which should be expanded with
%%# \expandafter.

%%#
%%# Searching and splitting
%%# -----------------------

%%# \toolboxSplitAt{argument}{search}{\beforestring}{\afterstring}
%%#
%%# Here, \beforestring and \afterstring are arbitrary macro names,
%%# and search and argument are any sequences of tokens (which are in
%%# the following considered as `strings').
%%#
%%# This call scans the string `argument' for the first occurrence of `search'.
%%# The macros \beforestring and \afterstring are defined correspondingly
%%# such that \beforestring expands to the part before the first occurrence,
%%# and \afterstring to the part following the first occurrence.
%%# If `search' does not occur in `argument', \beforestring is defined to
%%# `argument', and \afterstring is \let \undefined.
%%#
%%# If \beforestring or \afterstring had already been defined before the
%%# call, the previous definition is tacitly overridden.
%%# It is explicitly allowed that \beforestring and \afterstring are the
%%# same names. In this case, the result has the meaning of \afterstring.
%%#
%%# It is guaranteed that braces {...} are *not* lost in `argument'.
%%# However, `search' may not contain any braces, and `argument' may contain
%%# only matching pairs of braces. Moreover, occurrences of `search' within a
%%# pair of braces in `argument' are not recognized.
%%#
%%# In the above call, the arguments may not run over several paragraphs.
%%# If you want the latter, you have to use the alternative call
%%#
%%# \toolboxSplitAt*{argument}{search}{\beforestring}{\afterstring}
%%#
%%# Example of usage:
%%#
%%# \def\examplemacro#1{\toolboxSplitAt{#1}{@}\testme\testme
%%#   \ifx\testme\undefined
%%#      ... (do this when #1 contains no `@' token)
%%#   \fi}
%%#

%%# \toolboxMakeSplit{search}{command}
%%#
%%# If \toolboxSplitAt should be used several times with the same search
%%# string, it is much more effective to use the above call: This call
%%# defines a new macro \command (the name is determined by the second argument
%%# of \toolboxMakeSplit) which can be called in the form
%%#
%%#    \command{argument}{\beforestring}{\afterstring}
%%#
%%# and which has the analogous meaning as \toolboxSplitAt (the argument
%%# {search} is implicitly fixed and taken from the call of
%%# \toolboxMakeSplit).
%%# It is explicitly admissible that the above macro \toolboxMakeSplit is
%%# used with an already existing command name. In this case, the previous
%%# definition of \command is tacitly overridden.
%%#
%%# The command created by \toolboxMakeSplit does not accept arguments which
%%# run over several paragraphs. If you want the latter, you have to create
%%# this command by the alternative call
%%#
%%# \toolboxMakeSplit*{search}{command}

%%#
%%# The command
%%#    \toolboxFreeSplit{command}
%%# frees the memory used by a previous \toolboxMakeSplit (and lets \command
%%# again be undefined).

%%#
%%# Redefinition of macros
%%# ----------------------

%%# \toolboxMakeHarmless{\macro}
%%#
%%# The above call redefines \macro such that it expands to an ASCII text
%%# containing the previous definition of \macro.

%%# \toolboxDropBrace\variable
%%#
%%# drops possible outer braces in \variable. More precisely,
%%# if \variable expands to {content}, then \variable is redefined to
%%# content (without braces). Otherwise, nothing happens.

%%#
%%# \toolboxIf\comparison{DefinitionCommand}{\macro}...
%%#
%%# The above command allows conditional definitions.
%%# Here, {DefinitionCommand} is either \def, {\long\def}, \let, or some
%%# similar command like the LaTeX \newcommand. If the test
%%# \ifx\comparison\macro evaluates positive, then \macro is defined
%%# correspondingly. Otherwise, \macro is not changed.
%%#
%%# Examples:
%%#
%%# \toolboxIf\undefined\def\macro{....}
%%# \toolboxIf\undefined\let\macro...
%%# \toolboxIf\undefined{\long\def}\macro{....}
%%# \toolboxIf\undefined\newcommand{\macro}{....}
%%#
%%# are similar to \def\macro{...} resp. \let\macro... resp.
%%# \long\def\macro{...} resp. \newcommand{\macro}{...} with the difference
%%# that \macro is not changed if it was already defined.
%%#

%%# \toolboxNewiftrue{name} or \toolboxNewiffalse{name}
%%#
%%# If the command \ifname was already introduced with \newif, then
%%# nothing happens. Otherwise \ifname is introduced similarly to
%%# \newif\ifname and set to `true' respectively `false'.
%%# In contrast to the corresponding command in TeX or LaTeX 2.09, this macro
%%# is not \outer!

%%# \toolboxNewifTrue{name} or \toolboxNewifFalse{name}
%%#
%%# are similar to \toolboxNewiftrue{name} and \toolboxNewiffalse{name},
%%# respectively, with the difference that \ifname is set unconditionally
%%# to `true' respectively `false'.

%%#
%%# Concatenated macro names
%%# ------------------------

%%# \toolboxLet\variable{macroname}
%%#
%%# The above command is analogous to \let\variable\macroname with the
%%# difference that macroname can also contain other tokens like numbers
%%# (it is obtained via \csname). Some converse to this command is
%%#
%%# \toolboxWithNr {number}\cmd{macro}
%%#
%%# which translates into \cmd\macronumber (here, `macro' and `number'
%%# are just concatenated and evaluated via \csname).
%%# Examples:
%%#   \toolboxWithNr 1\let{name}\toolboxEmpty
%%#        This is the same as \let\name1\toolboxEmpty
%%#            (but such that \name1 is considered as a name, not as \name 1)
%%#   \toolboxWithNr {10}\def{name}{Foo}
%%#        This corresponds analogously to \def\name10{Foo}.
%%#   \toolboxLet \mymacro{name\the\mycount}
%%#        This is similar to \let\mymacro\namexx where xx is the content
%%#        of the counter \mycount.

%%#
%%# Various
%%# -------

%%# The macro
%%#    \toolboxEmpty
%%# expands to nothinh (usually, this is the same as \empty, but we do not want
%%# to rely on this). Similarly, the macro
%%#    \toolboxSpace
%%# expands to a space symbol (usually, this is the same as \space).
%%# The token
%%#    \toolboxSpaceToken
%%# is \let a space token. This token is convenient in tests of tokens
%%# (because it is hard to get a space there which is not eaten by the TeX
%%#  parser, although sometimes also constructions like
%%#  \expandafter\ifx\toolboxSpace\token can be used).

%  This is the end of the ascii documentation
%</asciidocu>
%\fi\catcode\#6\relax
%
% \iffalse
%<*metainfo>
% \fi

% \def\basename{toolbox}

%% \CharacterTable
%%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%%   Digits        \0\1\2\3\4\5\6\7\8\9
%%   Exclamation   \!     Double quote  \"     Hash (number) \#
%%   Dollar        \$     Percent       \%     Ampersand     \&
%%   Acute accent  \'     Left paren    \(     Right paren   \)
%%   Asterisk      \*     Plus          \+     Comma         \,
%%   Minus         \-     Point         \.     Solidus       \/
%%   Colon         \:     Semicolon     \;     Less than     \<
%%   Equals        \=     Greater than  \>     Question mark \?
%%   Commercial at \@     Left bracket  \[     Backslash     \\
%%   Right bracket \]     Circumflex    \^     Underscore    \_
%%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%%   Right brace   \}     Tilde         \~}

% \CheckSum{614}

% \iffalse
%   \RecordChanges
% \fi
% \def\mypar{}
% \def\ChangesTab{}\let\orichanges\changes
% \def\changes#1#2#3{\orichanges{#1}{#2}{#3}
%   \expandafter\def\expandafter\ChangesTab\expandafter{\ChangesTab
%   \item[v#1 {\mdseries(\emph{#2})}] {#3.}}}
% \newcommand{\cmdcite}[1]{\texttt{\textbackslash#1}}

% \changes{3.2}{2001/05/08}{Eliminated a serious bug in \cmdcite{toolboxIf}.
%    Due to this bugfix, the usage of \cmdcite{toolboxIf} had to be slightly
%    restricted}
% \changes{3.1}{2001/05/06}{Major advantage: \cmdcite{toolboxMakeDef}
%    implemented.\mypar
%    Reimplemented \cmdcite{newif} (because by Knuth's stupid idea, this is
%    declared as \cmdcite{outer} in \TeX\ and \LaTeX 2.09 which caused an
%    error during loading of \texttt{toolbox.sty}).
%    For this reason, also \cmdcite{toolboxNewifTrue} and
%    \cmdcite{toolboxNewifFalse} were introduced}
% \changes{2.1}{2001/04/30}{Introduced \cmdcite{toolboxIf},
%    \cmdcite{toolboxAppend}, and \cmdcite{toolboxSurround}}
% \changes{2.0}{2001/04/08}{Many major enhancements and new tools:
%    Added section (and corresponding macros)
%    for fancy optional arguments. Made \cmdcite{toolboxLoop} semi-reentrant by
%    introducing \cmdcite{toolboxLoopName}.
%    Added \cmdcite{toolboxTokenLoop} and friends.
%    Added \cmdcite{toolboxSpaceToken}.
%    Made many macros \cmdcite{long} and added \cmdcite{long} versions
%    of \cmdcite{toolboxSplitAt} and \cmdcite{toolboxMakeSplit}}
% \changes{1.0}{2001/03/29}{First release}
%
% \iffalse
%
% The following part is the code needed to compile the documentation.
% We do some trickery here, because we want that this file here could be used
% for *both*: Compiling the documentation *and* as `toolbox.sty'
% (if really required).
% Everything between the lines %<*driver> and %</driver>
% goes to the file `toolbox.tex'.
%
% \fi
\ifcat @a% If this test is positive, then `@' has letter catcode which means
%          that this file is loaded as a style file (or as described in the
%          install section of the documentation).
\def\TemporaryDummy{}
\else\long\def\TemporaryDummy{%
%
%
% \iffalse
%</metainfo>
%<*driver>
\documentclass{ltxdoc}
\OnlyDescription%% Comment this out, or
%%\AlsoImplementation%% uncomment this line, if you want to see the source.

%% If you want an index, uncomment one of the following lines.
%% After running latex a first time, you have to use
%%      makeindex -s gind.ist toolbox
%% Then run latex again.
%%\CodelineIndex% comment this out if you want an index referring to codelines
%%\PageIndex% comment this out if you want an index referring to pages
%%\OldMakeindex% uncomment this line, if your MakeIndex is pre-v2.9

\setlength\hfuzz{15pt}
\hbadness=7000
\begin{document}
\DocInput{toolbox.dtx}
\end{document}
%</driver>
%<*metainfo>
% \fi
}
\fi\TemporaryDummy\let\TemporaryDummy\undefined
%
% \iffalse
%          Personal macros used for the doc utility:
% \fi
% \MakeShortVerb{"}
% \def\bracemeta#1{\texttt{\{}\meta{#1}\texttt{\}}}
% \def\cmdmeta{\textbackslash\meta}
% \def\nocomment{}
% \def\myspace{\texttt{\textvisiblespace}}
% \parindent0pt

% \title{The \texttt{toolbox} package\thanks
%   {This  file has version number \fileversion{}, last revised \filedate.}}
% \author{Martin V\"ath\thanks
%   {\texttt{vaeth@mathematik.uni-wuerzburg.de}}}
% \date{\docdate}
% \maketitle

% \begin{abstract}
%  The \TeX\ programmer's toolbox; enhanced version.
%  This package provides some macros which are convenient for writing
%  indices, glossaries, or other macros. It contains macros which support
%  \begin{itemize}
%    \item implicit macros -- a useful supplement to \cmdcite{index} or
%          \texttt{varindex} for writing glossaries or indices.
%    \item fancy optional arguments
%    \item loops over tokenlists and itemlists
%    \item searching and splitting
%    \item controlled expansion
%    \item redefinition of macros
%    \item concatenated macro names
%  \end{itemize}
% \end{abstract}

% You may copy this package freely, as long as you distribute only unmodified
% and complete versions.

% \tableofcontents

% \section{Changes}
%
% \begin{description}
%    \def\mypar{\par}\ChangesTab
% \end{description}
%

% \section{Installation}

% This package was tested with \TeX, \LaTeX 2.09, and \LaTeXe, and it
% should actually run with all other \TeX\ formats.

% To use ``toolbox'', you have to put the file "toolbox.sty" in a path where
% \TeX\ looks for its input files. The \TeX\ documents using toolbox need the
% following modifications in their header:
%
% \begin{itemize}
% \item If you use \LaTeXe, put in the preamble the command
%   \begin{verbatim}
%     \usepackage{toolbox}\end{verbatim}
%
% \item If you use \LaTeX 2.09, use "toolbox" as a style option, e.\,g.\
%   \begin{verbatim}
%     \documentstyle[toolbox]{article}\end{verbatim}
%    or
%   \begin{verbatim}
%     \documentstyle[toolbox,12pt]{article}\end{verbatim}
%
% \item If you use some other (non-\LaTeX) format, you will probably have to
%    insert a line like
% \begin{verbatim}
% \catcode`\@=11\input toolbox.sty\catcode`\@=12\relax\end{verbatim}
%
% \end{itemize}
%
% The only \LaTeX-specific commands used in "toolbox.sty" are:
%
% \begin{itemize}
% \item "\newcommand" (used only in the form "\newcommand{"\meta{command}"}{}"
%       to ensure that \meta{command} was not defined before)
% \item "\ProvidesPackage"
% \item "\typeout"
% \end{itemize}
% The above commands are used only if they are defined.

% \section{Description of the macros}
%
% General remark: Many macros could appear in several sections.
% For example, "\toolboxMakeDef" and "\toolboxSourround" might be considered
% as macros which support redefinitions of macros. However, we put them
% in different sections which perhaps explain better their nature.
%
% \subsection{Implicit macro definitions}
%
% What we mean by implicit macro definitions is probably best explained by
% the following examples which show the intended usage:\par\bigskip
%
% (In the following examples, we always refer to the "\index" command. Note
% that it may be more convenient to use for indices the "varindex" package in
% addition -- the documentation of "varindex" (release 2.3 or newer)
% gives additional hints and examples how these two (essentially independent)
% approaches can be combined in practice).\par\bigskip
%
% Assume that you want to write an index for a book which has rather
% long and complicated "\index" entries. The first idea that one might have in
% this connection is to put the various "\index" commands at the beginning of
% the document into several macros (one for each "\index" entry), and to use
% just these macros in the main text. For example, one might want to write
% near the beginning of the document commands like
% \begin{verbatim}
%   \newcommand{\Start}{\index{finish or end}}
%   \newcommand{\End}{\index{finish or end}}\end{verbatim}
% and then to use in the main text "\Start" and "\End" whenever a reference
% in the corresponding index to the current place is desired.
% However, this has two major disadvantages:
% \begin{enumerate}
% \item It is easy to forget that "\End" writes an index entry.
%       So the macro "\End" in the main text might be very confusing.
% \item You cannot choose short and intuitive macro names for common phrases,
%       because they are usually already reserved by \TeX, \LaTeX, or some
%       packages. For example, "\end" could not be used.
% \end{enumerate}
% To avoid these problems, one may be very disciplinary and call the
% involved macros systematically e.\,g.\ "\GlossaryStart" "\GlossaryEnd" etc.
% However, this produces terrible long and unreadable macro names in the main
% text.\par\bigskip
% The implicit macro definitions of "toolbox" provide a more convenient
% solution.
% The idea is that you do not use the corresponding macros directly but only
% implicitly by a call of other macros where your ``macro name'' is just an
% argument.\par
% Moreover, "toolbox" assists you in writing the corresponding definitions.
% For example, if you know that you want a set of macros which all expand
% into something of the form "\index{...}", you can give a ``mask'' which
% contains this form, and you only have to fill in the changing content
% (similarly as for usual \TeX\ macros with arguments, but the level of
% abstraction is one step higher).
% For the above task, you might use the command:
% \begin{verbatim}
%    \toolboxMakeDef{Glossary}{\index{#1}}\end{verbatim}
%
% The argument "Glossary" serves to distinguish independent definitions
% (this will become clear later). Its effect visible now is that it
% determines the name of the following macros which you can use after
% the above call:
% \begin{verbatim}
%    \NewGlossary{start-1}{start}
%    \NewGlossary{start-2}{start or beginning}
%    \NewGlossary{end}{finish or end}\end{verbatim}
%
% These command are now similar to the "\newcommand" definitions explained
% above. However, there is no name collision with the \TeX-internal command
% "\end". Of course, this means that you cannot just write "\end" in the main
% text to get the desired index entry. Instead, you have to write the more
% intuitive commands
% \begin{verbatim}
%    \Glossary{start-1}
%    \Glossary{start-2}
%    \Glossary{end}\end{verbatim}
% (again, the name "\Glossary" stems from our first call of "\toolboxMakeDef").
% Note that e.\,g.\ "\Glossary{start-1}" expands not only to "start" but
% actually to "\index{start}" (because of our first call of
% "\toolboxMakeDef").\par
% Note also that you can use symbols like ``-'' or numbers which are
% usually not allowed in \TeX\ macro names.
%
% Of course, similarly as for "\newcommand", you can also do other things with
% the macros. For example,
% \begin{verbatim}
%    \LetGlossary\tempname{end}
%    \NewGlossary*{finish}\tempname\end{verbatim}
%
% will first define "\tempname" to expand to the same text as "\Glossary{end}",
% and then defines a new entry "\Glossary{finish}" to expand to the same text
% as "\tempname". Hence, the above two lines make the calls "\Glossary{end}"
% and "\Glossary{finish}" equivalent.
%
% At the end of your list of "\NewGlossary" commands, you might want to put
% \begin{verbatim}
%    \toolboxFreeDef*{Glossary}\end{verbatim}
%
% The purpose of this command is that "\NewGlossary" cannot be used anymore
% (unless, of course, you define it again). So you cannot unintentionally
% add new entries to your glossary list (but you still can use "\Glossary{...}"
% to reference to the already produced entries).
% Moreover, the above command frees some memory which was needed for
% "\NewGlossary" to work.
%
% If you additionally want to free the memory used by "\Glossary", you can use
% \begin{verbatim}
%    \toolboxFreeDef{Glossary}\end{verbatim}
%
% (without the "*"). This may be necessary, if you want to call again e.\,g.
% \begin{verbatim}
%    \toolboxMakeDef{Glossary}{\emph{#1}\index{#1}}\end{verbatim}
%
% (if you have not freed the memory for "\Glossary" before this repeated call,
% \TeX\ will complain that "\Glossary" is already defined).\par\smallskip
%
% Of course, it is possible to call "\toolboxMakeDef" with several different
% names, for example, for "\Glossary", "\SymbolList" etc. Another application
% might be to use a different command to mark e.\,g.\ the main occurrence of
% some index entry or to output additionally the entry into the running text.
% We do this in the following example which simultaneously
% demonstrates that the names can also be constructed in another way:
% \begin{verbatim}
%   \toolboxMakeDef[Ind]{}{\index{#1}}
%   \toolboxMakeDef[Ind]{Main}{\index{#1|textbf}}
%   \toolboxMakeDef{OutInd}{#1}
%
%   \IndNew{A}{A is a letter}
%   \IndNewMain{A}{A is a letter}
%   \NewOutInd{A}{\textbf{The letter A}\Ind{A}}\end{verbatim}
% After the above commands, you can use "\Ind{A}", "\IndMain{A}", and
% "\OutInd{A}" to produce the corresponding "\index" entry, the ``main''
% "\index" entry (with a fat page number), and the text \textbf{The letter A}
% with an additional entry into the index, respectively.
% Of course, it might usually be more convenient to define the "\Ind" and
% "\IndMain" entries simultaneously, e.\,g.\ by the commands
% \begin{verbatim}
%    \toolboxMakeDef[Ind]{}{#1}
%    \toolboxMakeDef[Ind]{Main}{#1}
%    \newcommand{\NewStandardInd}[2]{%
%       \IndNew{#1}{\index{#2}}%
%       \IndNewMain{#1}{\index{#2|textbf}}}
%
%    \NewStandardInd{A}{A is a letter}\end{verbatim}
% This approach has the additional advantage that you can define exceptional
% cases ``by hand'' (e.\,g.\ if you want that for certain ``main'' index
% entries the page number is printed with "\textsl" instead of "\textbf").
% \bigskip
%
% Since the motivation for implicit definitions now is hopefully clear,
% let us now describe in detail which commands are provided by "toolbox".
% As explained in the example, the main generic macro provided to this
% purpose is "\toolboxMakeDef". Its call syntax is as follows:
% \begin{quote}
% \DescribeMacro{\toolboxMakeDef}
% "\toolboxMakeDef["\meta{Prefix}"]"\bracemeta{Name}\relax
%\bracemeta{Replacement mask}
% \end{quote}
% (the argument "["\meta{Prefix}"]" is optional and by default empty).
% The above command generates new macros
%
% \begin{quote}
% \cmdmeta{Prefix}"New"\meta{Name}\\
% \cmdmeta{Prefix}"Renew"\meta{Name}\\
% \cmdmeta{Prefix}"Provide"\meta{Name}\\
% \cmdmeta{Prefix}"Let"\meta{Name}\\
% \cmdmeta{Prefix}\meta{Name}
% \end{quote}
% which in turn can be called as follows:
% \begin{quote}
% \cmdmeta{Prefix}"New"\meta{Name}\bracemeta{something}\relax
%\bracemeta{text to remember}\\
% \cmdmeta{Prefix}"Renew"\meta{Name}\bracemeta{something}\relax
%\bracemeta{text to remember}\\
% \cmdmeta{Prefix}"Provide"\meta{Name}\bracemeta{something}\relax
%\bracemeta{text to remember}\\
% \cmdmeta{Prefix}"New"\meta{Name}"*"\bracemeta{something}\relax
%{\cmdmeta{SomeMacro}}\\
% \cmdmeta{Prefix}"Renew"\meta{Name}"*"\bracemeta{something}\relax
%{\cmdmeta{SomeMacro}}\\
% \cmdmeta{Prefix}"Provide"\meta{Name}"*"\bracemeta{something}\relax
%{\cmdmeta{SomeMacro}}\\
% \cmdmeta{Prefix}"Let"\meta{Name}{\cmdmeta{SomeMacro}}\bracemeta{something}\\
% \cmdmeta{Prefix}\meta{Name}\bracemeta{something}
% \cmdmeta{Prefix}\meta{Name}"*"\bracemeta{something}
% \end{quote}
% These calls are in a sense similar to the respective commands
% \begin{quote}
% "\newcommand{"\cmdmeta{something}"}"\bracemeta{text to remember}\\
% "\renewcommand{"\cmdmeta{something}"}"\bracemeta{text to remember}\\
% "\providecommand{"\cmdmeta{something}"}"\bracemeta{text to remember}\\
% "\newcommand{"\cmdmeta{something}"}{}"\relax
%"\let"\cmdmeta{something}\cmdmeta{SomeMacro}\\
% "\renewcommand{"\cmdmeta{something}"}{}"\relax
%"\let"\cmdmeta{something}\cmdmeta{SomeMacro}\\
% "\let"\cmdmeta{something}\cmdmeta{SomeMacro}\\
% "\let"\cmdmeta{SomeMacro}{\cmdmeta{something}}\\
% \cmdmeta{something}\\
% \cmdmeta{something} (but without error if \cmdmeta{something} is undefined)
% \end{quote}
% with the differences already pointed out before:
% \begin{enumerate}
% \item The macro name actually used is not \cmdmeta{something}.
%   Instead, it is a name which does not conflict with any existing macro
%   (except one generated previously by another \cmdmeta{Prefix}New\meta{Name},
%   but in this case a descriptive error is output).\par
%   For this reason, it is not possible to use this macro directly but only
%   indirectly by the call \cmdmeta{Prefix}\meta{Name}\bracemeta{something}
%   (or with \cmdmeta{Prefix}Let\meta{Name}).
% \item The replacement text is not \meta{text to remember} but determined by
%   \meta{Replacement Mask} where every occurrence of "#1" in
%   \meta{Replacement Mask} is replaced by \meta{text to remember}
%   (recall the examples). If you want to have the plain
%   \meta{text to remember}, use "{#1}" as \meta{Replacement Mask}.
% \end{enumerate}
%
% "\toolboxMakeDef" gives an error message if the commands
% \cmdmeta{Prefix}"..." are already defined. If you intentionally want to
% change a previous definition, you have to call the command
%
% \begin{quote}
% \DescribeMacro{\toolboxFreeDef}
% "\toolboxFreeDef["\meta{Prefix}"]"\bracemeta{Name}
% \end{quote}
% before. The latter not only lets all of the macros \cmdmeta{Prefix}"..." be
% "\undefined", but also frees all other memory internally used by the
% corresponding call of "\toolboxMakeDef"
% (note, however, that the above command does not free the
% memory allocated before by calls of \cmdmeta{Prefix}"New..." -- to free the
% latter, you have to call subsequently e.\,g.
% \begin{quote}
% \cmdmeta{Prefix}"New"\meta{Name}"*{"$\ldots$"}{\undefined}"
% \end{quote}
% before). There is also the command
% \begin{quote}
% "\toolboxFreeDef*["\meta{Prefix}"]"\bracemeta{Name}
% \end{quote}
% which acts similarly as "\toolboxFreeDef" but which does not undefine the
% two macros \cmdmeta{Prefix}\meta{Name} and \cmdmeta{Prefix}"Let"\meta{Name}.
%

% \subsection{Fancy optional argument parsing}
%
% \begin{quote}
%   \DescribeMacro{\toolboxFuturelet}
%   "\toolboxFuturelet\token"\bracemeta{argument}
% \end{quote}
%
% The call "\toolboxFuturelet\token{\command}" has precisely the same effect as
% "\futurelet\token\command". The advantage of "\toolboxFuturelet" is that
% instead of a single "\command" one may use also a sequence of commands
% (which may take arguments).
%
% \begin{quote}
%  \DescribeMacro{\toolboxGobbleNext}
%  "\toolboxGobbleNext"\bracemeta{cmd}
% \end{quote}
% This erases the token following that command from the token stream and
% then executes \meta{cmd}. This is similar to
% \begin{verbatim}
%   \def\toolboxGobbleNext#1#2{#1}\end{verbatim}
% with the difference that "#2" is considered as a token and that no spaces
% are eaten.\par
% Example:
% \begin{verbatim}
%   \toolboxGobbleNext{\foo}{{arg}\end{verbatim}
% is the same as "\foo{arg}".

% \begin{quote}
% \DescribeMacro{\toolboxIfNextToken}
% "\toolboxIfNextToken"\bracemeta{token}\bracemeta{if}\bracemeta{else}
% \end{quote}
% If the token following this command is \meta{token}, then \meta{if} is
% executed, otherwise \meta{else}. It is explicitly admissible that
% \meta{token} is a space. In contrast to the corresponding \LaTeXe\ macros
% much care has been taken that spaces are not eaten. In particular, it is
% possible with this macro to define an optional argument at the end.
% To support further tests, "\toolboxToken" is "\let" to the token which
% follows the command. "\toolboxToken" is only a temporary token,
% i.\,e.\ it may also be modified by other commands of this package;
% in particular, it is also allowed to modify "\toolboxToken".\par
% The token "\toolboxSpaceToken" which is described later may be handy
% in connection with this command.\par
%
% Example:
% \begin{verbatim}
% \def\mycmd#1{\toolboxIfNextToken[{\ParseOpt{#1}}{\NoOpt{#1}}}
%    \def\ParseOpt#1[#2]{\OptAtEnd{#1}{#2}}\end{verbatim}
% After the above definition, "\mycmd{arg}" executes "\NoOpt{arg}" while
% "\mycmd{arg}[optional]" executes "\OptAtEnd{arg}{optional}".
% We point out once more that in the first call a space following
% "\mycmd{arg}" does not vanish (as would be the case if the \LaTeXe\ macros
% would have been used).

%
% \begin{quote}
% \DescribeMacro{\toolboxIfNextGobbling}
% "\toolboxIfNextGobbling"\bracemeta{token}\bracemeta{if}\bracemeta{else}
% \end{quote}
% This command is analogous to "\toolboxIfNextToken" with the difference that
% in the case that the next token is \meta{token}, it is gobbled before
% \meta{if} is executed.\par
%
% Example:
% \begin{verbatim}
% \def\my{\toolboxIfNextGobbling*\toolboxTokenLoop\toolboxLoop}\end{verbatim}
% This makes "\my*..." behave like "\toolboxTokenLoop..." and
% "\my..." (without "*") behave like "\toolboxLoop...".

% \subsection{Loops over tokenlists and itemlists}
%
% \begin{quote}
% \DescribeMacro{\toolboxLoop}
% "\toolboxLoop"\bracemeta{items}\bracemeta{action}
% \end{quote}
%
% This calls iteratively \meta{action}"{#1}", where "#1" runs over each item in
% \meta{items}. Here, an item is either a token or a group
% braced by "{...}".
% In the latter case, the braces are lost. Spaces in \meta{items} are ignored
% (unless they are braced). It is admissible that \meta{action} is not a single
% macro but instead a sequence of tokens.\par

% "\toolboxLoop" is not reentrant. To enable independent or recursive
% calls, the command
% \begin{quote}
% \DescribeMacro{\toolboxLoopName}
% "\toolboxLoopName"\bracemeta{name}\bracemeta{items}\bracemeta{action}
% \end{quote}
% is provided which is analogous to "\toolboxLoopName" and also not reentrant.
% But in contrast to "\toolboxLoop", calls with different \meta{name} can
% be used independently of each other. In particular, using a counter in
% \meta{name}, one could easily implement even recursive calls. In this
% connection, it should be noted that \meta{name} is expanded via
% "\csname ... \endcsname", and so you may use constructs like
% "\the\namecounter" there.\par

% \begin{quote}
% \DescribeMacro{\toolboxTokenLoop}
% "\toolboxTokenLoop"\bracemeta{tokens}\bracemeta{action}
% \end{quote}
% This is similar to "\toolboxLoop": The command \meta{action}"\toolboxToken"
% is executed iteratively where "\toolboxToken" runs over each token in
% \meta{tokens}. The important difference is that "\toolboxToken" is a token
% (instead of an item). In particular, "\toolboxToken" runs through every
% single token including spaces and braces.\par
% The token "\toolboxSpaceToken" which is described later may be handy
% in connection with this command.\par

% "\toolboxTokenLoop" is not reentrant. Analogously to "\toolboxLoopName",
% independent versions can be generated by
% \begin{quote}
% \DescribeMacro{\toolboxTokenName}
% "\toolboxTokenName"\bracemeta{name}\bracemeta{tokens}\bracemeta{action}
% \end{quote}

% \subsection{Controlled expansion}
%
% \begin{quote}
% \DescribeMacro{\toolboxDef}
% "\toolboxDef\macrotodefine"\bracemeta{argumentlist}
% \end{quote}
%
% This call is similar to
% \begin{quote}
% "\def\macrotodefine"\bracemeta{argumentlist}
% \end{quote}
% with two important differences:
%
% For "\toolboxDef", \meta{argumentlist} is expanded precisely by one level.
% \meta{argumentlist} may not contain macros with parameters, and spaces in the
% highest level are ignored. If you want to force a space on a particular
% place, use the macro \DescribeMacro{\toolboxSpace}"\toolboxSpace" at this
% place (which is described later).
%
% Example of usage:
% \begin{verbatim}
%    \toolboxDef\chain{\chain\toolboxSpace\after}\end{verbatim}
% This modifies the macro "\chain" such that a space and the content of the
% macro "\after" is appended at the end.
%
% \begin{quote}
% \DescribeMacro{\toolboxAppend}
% "\toolboxAppend\macrotodefine"\bracemeta{argumentlist}
% \end{quote}
% This is equivalent to
% \begin{quote}
% "\toolboxDef\macrotodefine{\macrotodefine"\meta{argumentlist}"}"
% \end{quote}
% \par

% The macro
% \begin{quote}
% \DescribeMacro{\toolboxSurround}
% "\toolboxSurround"\bracemeta{content before}\bracemeta{content after}"\macro"
% \end{quote}
% redefines "\macro" such that \meta{content before} is put at the
% beginning and \meta{content after} after the definition of "\macro".
% So this is equivalent to
% \begin{quote}
% "\def\macro{"\meta{content before}\meta{old content of \cmdcite{macro}}\relax
%\meta{content after}"}"
% \end{quote}
% The order of the arguments may appear strange, but it is convenient if
% \meta{content before} or \meta{content after} are macros which should be
% expanded with "\expandafter".

% \subsection{Searching and splitting}
%
% \begin{quote}
% \DescribeMacro{\toolboxSplitAt}
% "\toolboxSplitAt"\bracemeta{argument}\bracemeta{search}\relax
%"{\beforestring}{\afterstring}"
% \end{quote}
%
% Here, "\beforestring" and "\afterstring" are arbitrary macro names,
% and \meta{search} and \meta{argument} are any sequences of tokens (which
% are in the following considered as `strings').
%
% This call scans \meta{argument} for the first occurrence of \meta{search}.
% The macros "\beforestring" and "\afterstring"  are defined correspondingly
% such that "\beforestring" expands to the part before the first occurrence,
% and "\afterstring" to the part following the first occurrence.
% If \meta{search} does not occur in \meta{argument}, "\beforestring" is
% defined to \meta{argument}, and "\afterstring" is "\let" "\undefined".
%
% If "\beforestring" or "\afterstring" had already been defined before the
% call, the previous definition is tacitly overridden.
% It is explicitly allowed that "\beforestring" and "\afterstring" are the
% same names. In this case, the result has the meaning of "\afterstring".
%
% It is guaranteed that braces "{...}" are \emph{not} lost in \meta{argument}.
% However, \meta{search} may not contain any braces, and \meta{argument} may
% contain only matching pairs of braces. Moreover, occurrences of \meta{search}
% within a pair of braces in \meta{argument} are not recognized.
%
% In the above call, the arguments may not run over several paragraphs.
% If you want the latter, you have to use the alternative call
% \begin{quote}
% "\toolboxSplitAt*"\bracemeta{argument}\bracemeta{search}\relax
%"{\beforestring}{\afterstring}"
% \end{quote}

%
% Example of usage:
%
% \begin{verbatim}
% \def\examplemacro#1{\toolboxSplitAt{#1}{@}\testme\testme
%   \ifx\testme\undefined
%      ... (do this when #1 contains no `@' token)
%   \fi}\end{verbatim}
%

% If "\toolboxSplitAt" should be used several times with the same
% \meta{search} string, it is much more efficient to use the following command:
%
% \begin{quote}
% \DescribeMacro{\toolboxMakeSplit}
% "\toolboxMakeSplit"\bracemeta{search}"{command}"
% \end{quote}
%
% This call defines a new macro "\command" (the name is determined by the
% second argument of "\toolboxMakeSplit") which can be called in the form
%
% \begin{quote}
% "\command"\bracemeta{argument}"{\beforestring}{\afterstring}"
% \end{quote}
%
% and which has the analogous meaning as "\SplitAt" (the argument
% \bracemeta{search} is implicitly fixed and taken from the call of
% "\toolboxMakeSplit").
% It is explicitly admissible that the above macro "\toolboxMakeSplit" is
% used with an already existing command name. In this case, the previous
% definition of "\command" is tacitly overridden.
%
% The command created by "\toolboxMakeSplit" does not accept arguments which
% run over several paragraphs. If you want the latter, you have to create
% this command by the alternative call
%
% \begin{quote}
% "\toolboxMakeSplit*"\bracemeta{search}"{command}"
% \end{quote}

% The command
% \begin{quote}
%    "\toolboxFreeSplit"\bracemeta{command}
% \end{quote}
% frees the memory used by a previous "\toolboxMakeSplit" (and lets "\command"
% again be undefined).

% \subsection{Redefinition of macros}
%
%
% \begin{quote}
% \DescribeMacro{\toolboxMakeHarmless}
% "\toolboxMakeHarmless{\macro}"
% \end{quote}
%
% The above call redefines "\macro" such that it expands to an ASCII text
% containing the previous definition of "\macro".

% The call
% \begin{quote}
% \DescribeMacro{\toolboxDropBrace}
% "\toolboxDropBrace{\macro}"
% \end{quote}
% drops possible outer braces of "\macro". More precisely,
% if "\macro" expands to \bracemeta{content}, then "\macro" is redefined
% to \meta{content} (without braces). Otherwise, nothing happens.

% The command
% \begin{quote}
% \DescribeMacro{\toolboxIf}
% "\toolboxIf"\meta{comparison}\bracemeta{definition commands}\relax
%\cmdmeta{macro}$\ldots$
% \end{quote}
% allows conditional definitions. Here, \bracemeta{definition command}
% is either "\def", "{\long\def}", "\let", or some similar command like
% e.\,g.\ the \LaTeX\ "\newcommand". If the test
% "\ifx"\meta{comparison}\cmdmeta{macro} evaluates positive, then
% \cmdmeta{macro} is defined correspondingly. Otherwise, \cmdmeta{macro}
% is not changed.\par\smallskip
%
% \textbf{Examples:}
%
% \begin{verbatim}
% \toolboxIf\undefined\def\macro{....}
% \toolboxIf\undefined\let\macro...
% \toolboxIf\undefined{\long\def}\macro{....}
% \toolboxIf\undefined\newcommand{\macro}{....}\end{verbatim}
%
% are similar to "\def\macro{...}" resp.\ "\let\macro..."
% resp.\ "\long\def\macro{...}" resp.\ "\newcommand{\macro}" with the
% difference that "\macro" is not changed if it was already defined.\par
%

% The commands
% \begin{quote}
% \DescribeMacro{\toolboxNewiftrue}
%   "\toolboxNewiftrue"\bracemeta{name}\\
% \DescribeMacro{\toolboxNewiffalse}
%   "\toolboxNewiffalse"\bracemeta{name}
% \end{quote}
% test whether the command "\if"\meta{name} was already introduced with
% "\newif"; in this case nothing happens. Otherwise, "\if"\meta{name} is
% introduced similarly to "\newif\if"\meta{name} and set to "true"
% respectively "false".
% In contrast to the corresponding command in \TeX\ or \LaTeX 2.09, this macro
% is not "\outer"!
% \begin{quote}
% \DescribeMacro{\toolboxNewifTrue}
%   "\toolboxNewifTrue"\bracemeta{name}\\
% \DescribeMacro{\toolboxNewifFalse}
%   "\toolboxNewifFalse"\bracemeta{name}
% \end{quote}
% are similar to "\toolboxNewiftrue"\bracemeta{name} and
% "\toolboxNewiffalse"\bracemeta{name}, respectively,
% with the difference that "\if"\meta{name} is set unconditionally
% to "true" respectively "false".

% \subsection{Concatenated macro names}
%
% \begin{quote}
% \DescribeMacro{\toolboxLet}
% "\toolboxLet\variable"\bracemeta{macroname}
% \end{quote}
% The above command is analogous to "\let\variable\macroname" with the
% difference that \meta{macroname} can also contain other tokens like numbers
% (it is obtained via "\csname"). Some converse to this command is
%
% \begin{quote}
% "\toolboxWithNr"\bracemeta{number}"\command"\bracemeta{macro}
% \end{quote}
% which translates into "\command\macronumber" (here, \meta{macro} and
% \meta{number} are just concatenated and evaluated via "\csname").
% Examples:
% \begin{verbatim}
%   \toolboxWithNr 1\let{name}\toolboxEmpty\end{verbatim}
% This is the same as "\let\name1\toolboxEmpty" (but such that "\name1" is
% considered as a name, not as "\name 1")
% \begin{verbatim}
% \toolboxWithNr {10}\def{name}{Foo}\end{verbatim}
% This corresponds analogously to "\def\name10{Foo}".
% \begin{verbatim}
% \toolboxLet\mymacro{name\the\mycount}\end{verbatim}
% This is similar to "\let\mymacro\namexx" where "xx" is the content
% of the counter "\mycount".

% \subsection{Various}
%
% The macro
% \begin{quote}
%    \DescribeMacro{\toolboxEmpty}"\toolboxEmpty"
% \end{quote}
% expands to nothing (usually, this is the same as "\empty", but we do not want
% to rely on this). Similarly, the macro
% \begin{quote}
%    \DescribeMacro{\toolboxSpace}"\toolboxSpace"
% \end{quote}
% expands to a space symbol (usually, this is the same as "\space").
% The token
% \begin{quote}
%    \DescribeMacro{\toolboxSpaceToken}"\toolboxSpaceToken"
% \end{quote}
% is "\let" a space token. This token is convenient in tests of tokens
% (because it is hard to get a space there which is not eaten by the
% \TeX\ parser, although sometimes also constructions like
% \begin{verbatim}
%   \expandafter\ifx\toolboxSpace\token\end{verbatim}
% can be used).


% \iffalse
%</metainfo>
% \fi
% \iffalse--------------------------------------------------------------\fi
% \StopEventually{\PrintChanges}
%                     \section{Implementation}
%
% \iffalse--------------------------------------------------------------
%
%
%<*package>
% \fi
%    \begin{macrocode}
%%
%% This file was generated by the docstrip utility from toolbox.dtx.
%% You may distribute this file only together with the source toolbox.dtx
%% (and if possible with toolbox.ins) and only if these files are unmodified.
%%
%% Author:
%%
%% M. V\"ath      vaeth@mathematik.uni-wuerzburg.de
%%

\ifx\typeout\undefined
  \def\tbx@tmp{\immediate\write17}
\else
  \let\tbx@tmp\typeout
\fi\tbx@tmp{toolbox.sty by M. Vaeth: The TeX Programmer's Toolbox 3.2}

%% First, some LaTeX support:
%% We inform LaTeX that this is a package, and we test whether we would
%% override some existing commands.

\ifx\ProvidesPackage\undefined\else
  \ProvidesPackage{toolbox}[2001/05/08 v3.2]
\fi

\ifx\newcommand\undefined\else
  \newcommand{\toolboxMakeDef}{}
  \newcommand{\toolboxFreeDef}{}
  \newcommand{\toolboxFuturelet}{}
  \newcommand{\toolboxGobbleNext}{}
  \newcommand{\toolboxIfNextToken}{}
  \newcommand{\toolboxIfNextGobbling}{}
  \newcommand{\toolboxLoop}{}
  \newcommand{\toolboxLoopName}{}
  \newcommand{\toolboxToken}{}
  \newcommand{\toolboxTokenName}{}
  \newcommand{\toolboxDef}{}
  \newcommand{\toolboxAppend}{}
  \newcommand{\toolboxSplitAt}{}
  \newcommand{\toolboxMakeSplit}{}
  \newcommand{\toolboxFreeSplit}{}
  \newcommand{\toolboxMakeHarmless}{}
  \newcommand{\toolboxDropBrace}{}
  \newcommand{\toolboxIf}{}
  \newcommand{\toolboxNewiftrue}{}
  \newcommand{\toolboxNewiffalse}{}
  \newcommand{\toolboxLet}{}
  \newcommand{\toolboxWithNr}{}
  \newcommand{\toolboxEmpty}{}
  \newcommand{\toolboxSpace}{}
  \newcommand{\toolboxSpaceToken}{}
\fi

%    \end{macrocode}
% \subsection{Macros for various purposes}
% \begin{macro}{\toolboxSpace}\nocomment
%    \begin{macrocode}
\def\toolboxEmpty{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxSpace}\nocomment
%    \begin{macrocode}
\def\toolboxSpace{ }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxSpaceToken}
%  We cannot just write
%  \begin{verbatim*}\let\toolboxSpaceToken= \end{verbatim*}
%  because then the space would be eaten by \TeX's parser.
%  Also tries like
%  \begin{verbatim}
%  \expandafter\let\expandafter\toolboxSpaceToken\toolboxSpace\end{verbatim}
%  do not work for similar reasons. In contrast,
%  \begin{verbatim}
%  \futurelet\toolboxSpaceToken{ }\end{verbatim}
%  is possible (because the space is not `really' parsed at this time),
%  but it would have the side effect that the group "{ }" is executed which
%  forces a space output. We could artificially `eat' this output in some box.
%  But we proceed differently by replacing "{ }" in
%  the above call by an appropriate "\if...\fi". Of course, we have to take
%  care that the space is not eaten too early.
%    \begin{macrocode}
\expandafter
  \futurelet\expandafter\toolboxSpaceToken\expandafter
    \if\toolboxSpace\toolboxEmpty\toolboxEmpty\fi

%    \end{macrocode}
% \end{macro}
%
% \subsection{Macros supporting implicit macro definitions}
%
% \begin{macro}{\toolboxMakeDef}\nocomment
%    \begin{macrocode}
\def\toolboxMakeDef{\tbx@MakeNames\tbx@MakeDef}
%    \end{macrocode}
%  \begin{macro}{\tbx@MakeDef}
% The macros for "\toolboxMakeDef" are defined with
% \begin{quote}
%  "\tbx@MakeDef\PrefixNewName\PrefixRenewName\PrefixProvideName%"\\
%  "  \PrefixLetName\PrefixName\tbx@e@Prefix@Name%"\\
%  "  "\bracemeta{Prefix}\bracemeta{Name}\bracemeta{Replacement Mask}
% \end{quote}
% Note that \meta{Replacement Mask} must be read implicitly, because it
% contains "#1" which is usually forbidden.
% The macro "\tbx@e@Prefix@Name" is defined as
% \begin{quote}
%   "\tbx@long\def\tbx@e@Name#1"\bracemeta{Replacement Mask}
% \end{quote}
% The macros generated by
% \begin{quote}
% "\PrefixNewName"\bracemeta{something}"{"$\ldots$"...}"
% \end{quote}
% carry the names
% \begin{quote}
% "\tbx@l@"\meta{Prefix}"@"\meta{Name}"@"\meta{something}
% \end{quote}
% Observe that the symbol "@" has currently has the exceptional letter catcode,
% so that there is no danger that the user mangles up the names (unless he
% uses "\makeatletter" which he should of course not do, usually).
% \makeatletter
%    \begin{macrocode}
\def\tbx@MakeDef#1#2#3#4#5#6#7#8{%
  \tbx@def#1{\toolboxIfNextGobbling*%
    {\tbx@MakeNew\let{#7}{#8}}{\tbx@MakeNew\def{#7}{#8}}}%
  \tbx@def#2{\toolboxIfNextGobbling*%
    {\tbx@MakeRenew\let{#7}{#8}}{\tbx@MakeRenew\def{#7}{#8}}}%
  \tbx@def#3{\toolboxIfNextGobbling*%
    {\tbx@MakeProvide\let{#7}{#8}}{\tbx@MakeProvide\def{#7}{#8}}}%
  \tbx@def#4##1##2{\expandafter
    \tbx@MakeLet\csname tbx@l@#7@#8@##2\endcsname##1}%
  \tbx@def#5{\toolboxIfNextGobbling*%
    {\tbx@MakeUse\tbx@itemEnd{#7}{#8}}{\tbx@MakeUse\relax{#7}{#8}}}%
  \long\def#6##1}

%    \end{macrocode}
%   \begin{macro}{\tbx@MakeNew}
% "\tbx@MakeNew"\bracemeta{mode}\relax
%\bracemeta{Prefix}\bracemeta{Name}\bracemeta{something}%
%\bracemeta{text to remember}
%    \begin{macrocode}
\def\tbx@MakeNew#1#2#3#4{\expandafter
  \ifx\csname tbx@l@#2@#3@#4\endcsname\relax\else
    \errmessage{#2New#3: entry #4 already exists}%
  \fi
  \tbx@MakeProvide{#1}{#2}{#3}{#4}}

%    \end{macrocode}
%   \end{macro}
%   \begin{macro}{\tbx@MakeRenew}
% "\tbx@MakeRenew"\bracemeta{mode}\relax
%\bracemeta{Prefix}\bracemeta{Name}\bracemeta{something}%
%\bracemeta{text to remember}
%    \begin{macrocode}
\def\tbx@MakeRenew#1#2#3#4{\expandafter
  \ifx\csname tbx@l@#2@#3@#4\endcsname\relax
    \errmessage{#2Renew#3: entry #4 was not defined before}%
  \fi
  \tbx@MakeProvide{#1}{#2}{#3}{#4}}

%    \end{macrocode}
%   \end{macro}
%   \begin{macro}{\tbx@MakeProvide}
% "\tbx@MakeProvide"\bracemeta{mode}\relax
%\bracemeta{Prefix}\bracemeta{Name}\bracemeta{something}%
%\bracemeta{text to remember}
%    \begin{macrocode}
\long\def\tbx@MakeProvide#1#2#3#4#5{%
  \ifx#1\let
    \expandafter
      \let\csname tbx@l@#2@#3@#4\endcsname#5%
  \else
    \expandafter
      \tbx@MakeDoDef\csname tbx@l@#2@#3@#4\expandafter\endcsname
        \csname tbx@e@#2@#3\endcsname{#5}%
  \fi}
%    \end{macrocode}
%    \begin{macro}{\tbx@MakeDoDef}
% \begin{quote}
% "\tbx@MakeDoDef"\relax
%"\tbx@l@"\meta{Prefix}"@"\meta{Name}"@"\meta{something}"%"\\
%"  \tbx@e@"\meta{Prefix}"@"\meta{Name}\bracemeta{text to remember}
% \end{quote}
%    \begin{macrocode}
\long\def\tbx@MakeDoDef#1#2#3{\expandafter
  \def\expandafter#1\expandafter{#2{#3}}}

%    \end{macrocode}
%    \end{macro}
%   \end{macro}
%   \begin{macro}{\tbx@MakeLet}
% "\tbx@MakeLet"\cmdmeta{Prefix}"@"\meta{Name}"@"\meta{something}\relax
%\cmdmeta{something}
%    \begin{macrocode}
\def\tbx@MakeLet#1#2{%
  \ifx#1\relax
    \let#2\undefined
  \else
    \let#2#1%
  \fi}

%    \end{macrocode}
%   \end{macro}
%   \begin{macro}{\tbx@MakeUse}
% "\tbx@MakeUse"\bracemeta{mode}\relax
%\bracemeta{Prefix}\bracemeta{Name}\bracemeta{something}
%    \begin{macrocode}
\def\tbx@MakeUse#1#2#3#4{%
  \expandafter
  \ifx\csname tbx@l@#2@#3@#4\endcsname#1%
    \errmessage{Entry #4 was not defined with #2New#3 or #2Provide#3}%
  \fi
  \csname tbx@l@#2@#3@#4\endcsname}

%    \end{macrocode}
%   \end{macro}
%   \begin{macro}{\tbx@def}
% "\tbx@def" is similar to "\def", but existence is tested (via "\relax")
%    \begin{macrocode}
\def\tbx@def#1{%
  \ifx#1\relax\else
    \errmessage{\string#1 is already defined}%
  \fi
  \def#1}

%    \end{macrocode}
%   \end{macro}
%  \end{macro}
%  \begin{macro}{\toolboxFreeDef}\nocomment
%    \begin{macrocode}
\def\toolboxFreeDef{\toolboxIfNextGobbling*%
  {\tbx@MakeNames{\tbx@FreeDef\relax}}{\tbx@MakeNames{\tbx@FreeDef\undefined}}}
%    \end{macrocode}
%   \begin{macro}{\tbx@FreeDef}
%  \begin{quote}
%  "\tbx@MakeDef"\bracemeta{mode}"\PrefixNewName\PrefixRenewName%"\\
%  "  \PrefixProvideName\PrefixLetName\PrefixName\tbx@e@Prefix@Name%"\\
%  "  "\bracemeta{Prefix}\bracemeta{Name}
%  \end{quote}
%  The last two arguments are not needed, but we must gobble them.
%    \begin{macrocode}
\def\tbx@FreeDef#1#2#3#4#5#6#7#8#9{%
  \let#2\undefined\let#3\undefined\let#4\undefined\let#7\undefined
  \ifx#1\undefined
    \let#5\undefined\let#6\undefined
  \fi}

%    \end{macrocode}
%   \end{macro}
%  \end{macro}
%  \begin{macro}{\tbx@MakeNames}
% The call
% \begin{quote}
%  "\tbx@MakeNames"\bracemeta{commands}"["\meta{Prefix}"]"\bracemeta{Name}
% \end{quote}
% (where the "["\meta{Prefix}"]" argument is optional) expands to
% \begin{quote}
%   \meta{commands}"\PrefixNewName\PrefixRenewName\PrefixProvideName%"\\
%   "  \PrefixLetName\PrefixName\tbx@e@Prefix@Name%"\\
%   "  "\bracemeta{Prefix}\bracemeta{Name}
% \end{quote}
%    \begin{macrocode}
\def\tbx@MakeNames#1{\toolboxIfNextToken[%]
  {\tbx@MakingNames{#1}}{\tbx@MakingNames{#1}[]}}
%    \end{macrocode}
%   \begin{macro}{\tbx@MakingNames}
%    \begin{macrocode}
\def\tbx@MakingNames#1[#2]#3{\expandafter
  \tbx@ListSwap\expandafter{%
    \csname#2New#3\expandafter\endcsname
    \csname#2Renew#3\expandafter\endcsname
    \csname#2Provide#3\expandafter\endcsname
    \csname#2Let#3\expandafter\endcsname
    \csname#2#3\expandafter\endcsname
    \csname tbx@e@#2@#3\endcsname{#2}{#3}}{#1}}
%    \end{macrocode}
%    \begin{macro}{\tbx@ListSwap}\nocomment
%    \begin{macrocode}
\def\tbx@ListSwap#1#2{#2#1}

%    \end{macrocode}
%    \end{macro}
%   \end{macro}
%  \end{macro}
% \end{macro}
%
% \subsection{Macros supporting fancy optional argument parsing}
%
% \begin{macro}{\toolboxFuturelet}
%    \begin{macrocode}
\long\def\toolboxFuturelet#1#2{\def\tbx@tmp{#2}\futurelet#1\tbx@tmp}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxGobbleNext}
%    \begin{macrocode}
\long\def\toolboxGobbleNext#1{\def\tbx@tmp{#1}\afterassignment\tbx@tmp
  \let\toolboxToken= }% The space here is important to read spaces properly

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxIfNextToken}
%    \begin{macrocode}
\long\def\toolboxIfNextToken#1#2#3{%
  \toolboxFuturelet\toolboxToken{%
    \ifx#1\toolboxToken
      \def\tbx@tmp{#2}%
    \else
      \def\tbx@tmp{#3}%
    \fi
    \tbx@tmp}}

%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxIfNextGobbling}
%    \begin{macrocode}
\long\def\toolboxIfNextGobbling#1#2#3{%
  \toolboxIfNextToken{#1}{\toolboxGobbleNext{#2}}{#3}}

%    \end{macrocode}
% \end{macro}
%
% \subsection{Macros supporting loops over tokenlists and itemlists}
%
% \begin{macro}{\toolboxLoop}
%    "\toolboxLoop" just calls "\tbx@item" with the magic names
%    "\tbx@i" and "\tbx@I".
%    \begin{macrocode}
\long\def\toolboxLoop#1#2{\tbx@item\tbx@i\tbx@I{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxLoopName}
%    "\toolboxLoopName" calls "\tbx@item" with the magic names "\tbx@i@#1"
%    and "\tbx@I#@1"
%    \begin{macrocode}
\long\def\toolboxLoopName#1#2#3{\tbx@LoopName{#1}iI\tbx@item{#2}{#3}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tbx@LoopName}
% \begin{verbatim}
%    \tbx@LoopName{name}{x}{y}{\exec}\end{verbatim}
%  is equivalent to
%  \begin{verbatim}
%    \exec\tbx@x@name\tbx@y@name\end{verbatim}
%    \begin{macrocode}
\def\tbx@LoopName#1#2#3#4{%
  \expandafter#4\csname tbx@#2@#1\expandafter\endcsname
    \csname tbx@#3@#1\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tbx@item}
% The call
% \begin{quote}
%    "\tbx@item{\MagicNameA}{\MagicNameB}"\bracemeta{items}\bracemeta{action}
% \end{quote}
% is the essential part of "\toolboxLoop". It has the same semantic with
% the only difference that the names "\MagicNameA" and "\MagicNameB" are used
% as temporary macros (they are the reason why "\tbx@item" is not reentrant).
%    \begin{macrocode}
\long\def\tbx@item#1#2#3#4{%
  \long\def#1##1{%
    \def\toolboxToken{##1}%
    \ifx\toolboxToken\tbx@itemEnd
      \def#2{\let#1\undefined\let#2\undefined}%
    \else
      #4{##1}%
    \fi
    #2}%
  \let#2#1%
  #1#3\tbx@itemEnd}
%    \end{macrocode}
%  \begin{macro}{\tbx@itemEnd}
%  "\tbx@itemEnd" is the magic token used to mark the end of the list in
%  "\tbx@item".
%  Of course, we could also use any other macro instead, but this is unique,
%  even if we compare with "\ifx". Moreover, we want a short macro to
%  avoid unnecessary redundancy in comparing with "\ifx".
%  It appears not necessary to make this token change in recursions, because
%  in each expansion of a list, the newest item will automatically be the
%  earliest.
%    \begin{macrocode}
\def\tbx@itemEnd{\tbx@itemEnd}

%    \end{macrocode}
%  \end{macro}
% \end{macro}
%
% \begin{macro}{\toolboxTokenLoop}
%    "\toolboxTokenLoop" just calls "\tbx@token" with the magic names
%    "\tbx@t" and "\tbx@T".
%    \begin{macrocode}
\long\def\toolboxTokenLoop#1#2{\tbx@token\tbx@t\tbx@T{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxTokenLoopName}
%   "\toolboxTokenLoopName" calls "\tbx@token" with the magic names "\tbx@t@#1"
%   and "\tbx@T#@1"
%    \begin{macrocode}
\long\def\toolboxTokenLoopName#1#2#3{\tbx@LoopName{#1}tT\tbx@token{#2}{#3}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tbx@token}
%  The call
%  \begin{quote}
%    "\tbx@token{\MagicNameA}{\MagicNameB}"\bracemeta{items}\bracemeta{action}
%  \end{quote}
%  is the essential part of "\toolboxTokenLoop". It has the same semantic with
%  the only difference that the names "\MagicNameA" and "\MagicNameB" are used
%  as temporary macros (they are the reason why "\tbx@token" is not reentrant).
%    \begin{macrocode}
\long\def\tbx@token#1#2#3#4{%
  \def#1{%
    \ifx\toolboxToken\tbx@tokenEnd
      \def#2{\let#1\undefined\let#2\undefined}%
    \else
      #4\toolboxToken
    \fi
    #2}%
  \def#2{\afterassignment#1\let\toolboxToken= }%
  #2#3\tbx@tokenEnd}
%    \end{macrocode}
%  \begin{macro}{\tbx@tokenEnd}
%  "\tbx@tokenEnd" is the magic token used to mark the end of the list
%  for "\tbx@token".
%  The same remarks as for "\tbx@itemEnd" hold. However, it is not clear
%  whether we could just use "\tbx@itemEnd" instead, because the scan rules
%  for "\tbx@token" and "\tbx@item" are somewhat different, and thus it is
%  not immediately clear whether in some fancy situations such lists (if
%  called cross-wise) could overlap: I found no example, but I also did not
%  put too much effort in finding one. In any case, we are on the sure side,
%  if we just use a different token.
%    \begin{macrocode}
\def\tbx@tokenEnd{\tbx@tokenEnd}

%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsection{Macros supporting controlled expansion}
%
% \begin{macro}{\toolboxDef}
%  This is mainly a call of "\toolboxLoopName". It is slightly faster if we
%  call "\tbx@item" immediately (and then we can also give magic name which do
%  not clash with any other names). Also for time and memory reasons, we always
%  assume that the temporary variable
%  \begin{macro}{\tbx@odeftmp}
%  "\tbx@odeftmp"
%  \end{macro}
%  is "\toolboxEmpty" at the beginning; we reset it to "\toolboxEmpty" at
% the end (so that the memory becomes free).
%    \begin{macrocode}
\def\toolboxDef#1#2{%
  \tbx@item\tbx@odefa\tbx@odefb{#2}\tbx@odef
  \let#1\tbx@odeftmp\let\tbx@odeftmp\toolboxEmpty}
\let\tbx@odeftmp\toolboxEmpty
%    \end{macrocode}
%  \begin{macro}{\tbx@odef}
%    \begin{macrocode}
\def\tbx@odef#1{\expandafter\tbx@odefapp\expandafter{#1}}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\tbx@odefapp}
%    "\tbx@odefapp" appends its argument to "\tbx@odeftmp".
%    \begin{macrocode}
\def\tbx@odefapp#1{\expandafter
  \def\expandafter\tbx@odeftmp\expandafter{\tbx@odeftmp#1}}

%    \end{macrocode}
%  \end{macro}
% \end{macro}
%
% \begin{macro}{\toolboxAppend}\nocomment
%    \begin{macrocode}
\def\toolboxAppend#1#2{\toolboxDef#1{#1#2}}

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\toolboxSurround}\nocomment
%    \begin{macrocode}
\long\def\toolboxSurround#1#2#3{%
  \def\tbx@tmp{#1}%
  \expandafter\expandafter\expandafter
    \def\expandafter\expandafter\expandafter
    #3\expandafter\expandafter\expandafter{\expandafter\tbx@tmp#3#2}}

%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Macros supporting searching and splitting}
%
% \begin{macro}{\toolboxMakeSplit}\nocomment
%    \begin{macrocode}
\def\toolboxMakeSplit{%
  \toolboxIfNextGobbling*\tbx@MakeLong\tbx@MakeShort}
%    \end{macrocode}
%
%  \begin{macro}{\tbx@Makelong}
%  \begin{quote}
%     "\tbx@Makelong"\bracemeta{search}"{cmd}"
%  \end{quote}
%   is the same as
%  \begin{quote}
%     "\tbx@DoSplitInstance{\cmd}{\tbx@cmd@spt}{\tbx@cmd@rst}"
%\bracemeta{search}"\long"
%  \end{quote}
%    \begin{macrocode}
\long\def\tbx@MakeLong#1#2{%
  \tbx@SplitNames{#2}%
  \expandafter
    \tbx@DoSplitInstance\tbx@splt{#1}\long}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\tbx@MakeShort}
%  "\tbx@Makeshort" is essentially the same as "\tbx@Makelong" (just that
%  "\long" is missing, of course). We could have used the same macro with
%  an additional argument, but it is more convenient for the user if this
%  macro itself is not "\long" so that new paragraphs in the passed search
%  string already give an error: It makes no sense to look for new paragraphs
%  in texts which may not contain new paragraphs.
%    \begin{macrocode}
\def\tbx@MakeShort#1#2{%
  \tbx@SplitNames{#2}%
  \expandafter
    \tbx@DoSplitInstance\tbx@splt{#1}{}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\tbx@SplitNames}
%   The call "\tbx@SplitNames{cmd}" is equivalent to
%    \begin{verbatim}
%    \def\tbx@splt{\cmd \tbx@cmd@spt \tbx@cmd@rst}\end{verbatim}
%    \begin{macrocode}
\def\tbx@SplitNames#1{%
  \expandafter
    \def\expandafter\tbx@splt\expandafter{\csname#1\expandafter\endcsname
      \csname tbx@#1@spt\expandafter\endcsname
      \csname tbx@#1@rst\endcsname}}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\tbx@DoSplitInstance}
% The call
%   \begin{quote}
%   "\tbx@DoSplitInstance{\cmd}{\tbx@cmd@spt}{\tbx@cmd@rst}"\bracemeta{search}
%\bracemeta{long}
%   \end{quote}
% creates the instance "\cmd" which splits its argument at
% \bracemeta{search} (also "\tbx@cmd@spt" and "\tbx@cmd@rst" are created
% which are needed for "\cmd" to work). The argument \meta{long} must be
% either "\long" or empty, depending whether long definitions are desired.\par
% The difficulty in the definition of "\cmd" is to ensure that "{xxx}|{yyy}"
% splits into "{xxx}" and "{yyy}" \emph{with} braces (i.\,e., we have to
% find out whether there are braces which are eliminated by \TeX\ as
% `argument braces'). Actually, this problem occurs only for the part "{yyy}".
% We solve it by appending an "a" to \meta{argument}, i.\,e., we actually
% split the string "{xxx}|{yyy}a". Of course, we have to eliminate the
% trailing "a" at the end.
%    \begin{macrocode}
\long\def\tbx@DoSplitInstance#1#2#3#4#5{%
  #5\def#1##1##2##3{%
    #2##2##3\toolboxEmpty##1#4#4@tbx@spt%
    \ifx##3\toolboxEmpty
      \let##3\undefined
    \else
      #3##3##1a@tbx@rst%
    \fi
  }%
  #5\def#2##1##2##3#4##4#4##5@tbx@spt{\expandafter
    \def\expandafter ##1\expandafter{##3}#5\def##2{##5}}%
  #5\def#3##1##2#4##3@tbx@rst{\tbx@rememberlasta##3@tbx@dropa%
    \tbx@defwithoutlasta##1##3@tbx@dropa}}
%    \end{macrocode}
%   \begin{macro}{\tbx@rememberlasta}
% The call
%    \begin{quote}
%    "\tbx@rememberlasta"\meta{arg}"@tbx@dropa"
%    \end{quote}
% (no braces: The magic string "@tbx@dropa" is used to find the end of
% \meta{arg}) is only admissible, if the last token in \meta{arg} is an "a".
% In this case, \DescribeMacro{\tbx@droplasta}"\tbx@droplasta" is
% defined as \meta{arg} without the trailing "a" (but it may happen that
% \meta{arg} looses surrounding braces), and the corresponding string with the
% trailing "a" (possibly without surrounding braces) is saved into
% \DescribeMacro{\tbx@rebuilda}"\tbx@rebuilda".
% This macro is used by the instances created
% by "\tbx@DoSplitInstance".
%    \begin{macrocode}
\long\def\tbx@rememberlasta#1a@tbx@dropa{\def\tbx@droplasta{#1}%
  \def\tbx@rebuilda{#1a}}
%    \end{macrocode}
%   \end{macro}
%   \begin{macro}{\tbx@defwithoutlasta}
% The call
%    \begin{quote}
%    "\tbx@defwithoutlasta{\afterstring}"\meta{arg}"@tbx@dropa"
%    \end{quote}
% (no braces: The magic string "@tbx@dropa" is used to find the end of
% \meta{arg}) is only admissible, if the last token in \meta{arg} is an "a".
% If \meta{arg} coincides with "\tbx@rebuilda",
% then we know that we did not loose any braces, and we set "\afterstring"
% to the content of "\tbx@droplasta"; otherwise we lost braces and thus
% have additionally to surround the content of "\afterstring" by braces.
%    \begin{macrocode}
\long\def\tbx@defwithoutlasta#1#2@tbx@dropa{\def\tbx@originala{#2}%
  \ifx\tbx@originala\tbx@rebuilda
%    \end{macrocode}
% Did we forget braces in "\tbx@rememberlasta"?
%    \begin{macrocode}
    \let#1\tbx@droplasta
  \else
    \expandafter
      \def\expandafter#1\expandafter{\expandafter{\tbx@droplasta}}%
  \fi}

%    \end{macrocode}
%   \end{macro}
%  \end{macro}
% \end{macro}
% \begin{macro}{\toolboxFreeSplit}\nocomment
%    \begin{macrocode}
\def\toolboxFreeSplit#1{%
  \tbx@SplitNames{#1}%
  \expandafter
    \toolboxLoop\expandafter{\tbx@splt}\tbx@freeSplit}
%    \end{macrocode}
%  \begin{macro}{\tbx@freeSplit}\nocomment
%    \begin{macrocode}
\def\tbx@freeSplit#1{\let#1\undefined}

%    \end{macrocode}
%  \end{macro}
% \end{macro}
% \begin{macro}{\toolboxSplitAt}
%  "\toolboxSplitAt" just calls "tbx@DoSplitInstance" with dummy temporary
%  variables and then executes the corresponding command.
%    \begin{macrocode}
\def\toolboxSplitAt{\toolboxIfNextGobbling*\tbx@SplitLong\tbx@SplitShort}
%    \end{macrocode}
%  \begin{macro}{\tbx@SplitLong}\nocomment
%    \begin{macrocode}
\long\def\tbx@SplitLong#1#2#3#4{%
  \tbx@DoSplitInstance\tbx@splt\tbx@splta\tbx@spltb{#2}\long
  \tbx@splt{#1}{#3}{#4}}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\tbx@SplitShort}
%    We cannot use just an additional argument in "\tbx@SplitLong", because
%    we really should use a non-"\long" macro to read the arguments.
%    \begin{macrocode}
\def\tbx@SplitShort#1#2#3#4{%
  \tbx@DoSplitInstance\tbx@splt\tbx@splta\tbx@spltb{#2}{}%
  \tbx@splt{#1}{#3}{#4}}

%    \end{macrocode}
%  \end{macro}
% \end{macro}
%
%
% \subsection{Macros supporting redefinition of macros}
%
% \begin{macro}{\toolboxMakeHarmless}\nocomment
%    \begin{macrocode}
\def\toolboxMakeHarmless#1{\edef#1{\tbx@Nearverbatim#1}}
%    \end{macrocode}
%  \begin{macro}{\tbx@Nearverbatim}\nocomment
%    \begin{macrocode}
\def\tbx@Nearverbatim{\expandafter\tbx@Meaning\meaning}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\tbx@Meaning}\nocomment
%    \begin{macrocode}
\long\def\tbx@Meaning#1>{}

%    \end{macrocode}
%  \end{macro}
% \end{macro}
%
% \begin{macro}{\toolboxDropBrace}\nocomment
%    \begin{macrocode}
\def\toolboxDropBrace#1{\expandafter\tbx@ForgetBrace#1@tbx@dropbrace#1}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tbx@ForgetBrace}\nocomment
%    \begin{macrocode}
\long\def\tbx@ForgetBrace#1@tbx@dropbrace#2{\def#2{#1}}

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\toolboxIf}\nocomment
%    \begin{macrocode}
\long\def\toolboxIf#1#2#3{%
  \ifx#1#3\def\tbx@tmp{#2#3}\else\def\tbx@tmp{#2\tbx@tmp}\fi\tbx@tmp}

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\toolboxNewiftrue}\nocomment
%    \begin{macrocode}
\def\toolboxNewiftrue#1{\tbx@newifexec{#1}{\csname#1true\endcsname}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxNewiffalse}\nocomment
%    \begin{macrocode}
\def\toolboxNewiffalse#1{\tbx@newifexec{#1}{\csname#1false\endcsname}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxNewiftrue}\nocomment
%    \begin{macrocode}
\def\toolboxNewifTrue#1{\tbx@newifexec{#1}{}\csname#1true\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxNewiffalse}\nocomment
%    \begin{macrocode}
\def\toolboxNewifFalse#1{\tbx@newifexec{#1}{}\csname#1false\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tbx@newifexec}
% \begin{quote}
%  "\tbx@newifexec"\bracemeta{name}\bracemeta{initialization}
% \end{quote}
% If the command "\if"\meta{name} already exists, nothing happens.
% Otherwise, the commands \cmdmeta{name}"true" and \cmdmeta{name}"false" are
% created (similarly as by the \TeX\ command "\newif"), and afterwards
% \meta{initialization} is executed. Here, \meta{initialization} should be
% either \cmdmeta{name}"true" or \cmdmeta{name}"false"
% which then defines "\if"\meta{name} to the desired default.
% (It may also be empty if you do this initialization immediately afterwards).
% \meta{initialization} should not contain any potential "\if" tokens.\par
% One must be very careful in the implementation of this macro,
% because "\if"'s are parsed very strange by \TeX.
% However, if an "\if"-command is the first token following our only "\ifx",
% we do not run into problems. Moreover, the first parsing until "\fi" does
% not see any further "\if", because it is hidden in "\csname" which has not
% been expanded by this time.
%    \begin{macrocode}
\def\tbx@newifexec#1#2{\expandafter
   \ifx\csname if#1\endcsname\relax
     \expandafter\tbx@newif\csname if#1\endcsname{#1}%
     #2%
   \fi}
%    \end{macrocode}
%  \begin{macro}{\tbx@newif}
%  It is rather annoying that D.\,E.~Knuth has introduced the "\outer"
%  directive:
%  The sole purpose of that command is to cause problems and to force people
%  to think how to get around these problems. It is especially irritating that
%  the standard command "\newif" was (before \LaTeXe) defined with this
%  attribute. To work in a normal way, we have to define "\newif" by hand
%  in a sane way. It is simpler for us, if we do not only pass the name as a
%  single token but additionally also the full name without "if".
%  So our simpler "\newif" macro is called as follows:
%  \begin{quote}
%  "\tbx@newif"\cmdmeta{ifname}\bracemeta{name}
%  \end{quote}
%  This macro does \emph{not} define \cmdmeta{ifname}. But gets automatically
%  defined after the first call of \cmdmeta{name}"true" or
%  \cmdmeta{name}"false" which should of course happen immediately afterwards.
%    \begin{macrocode}
\def\tbx@newif#1#2{%
  \expandafter
    \def\csname#2true\endcsname{\let#1\iftrue}%
  \expandafter
    \def\csname#2false\endcsname{\let#1\iffalse}}

%    \end{macrocode}
%  \end{macro}
% \end{macro}
%
% \subsection{Macros supporting concatenated macro names}
%
% \begin{macro}{\toolboxWithNr}\nocomment
%    \begin{macrocode}
\def\toolboxWithNr#1#2#3{\expandafter#2\csname #3#1\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\toolboxLet}\nocomment
%    \begin{macrocode}
\def\toolboxLet#1#2{\expandafter\let\expandafter#1\csname #2\endcsname}

%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</package>
% \fi
% \Finale\PrintIndex
%
%
%
% \iffalse
%<*metainfo>
% \fi
\iffalse -------------------------------------------------------------
%
% Just in case that for some reason the file `toolbox.ins' got lost:
% The content of this file is between the lines %<*insfile> and %</insfile>.
%
%\iffalse
%</metainfo>
%<*insfile>
\def\batchfile{toolbox.ins}
\input docstrip.tex
\keepsilent
\nopreamble
\generateFile{toolbox.sty}{f}{\from{toolbox.dtx}{package}}
\generateFile{toolbox.txt}{f}{\from{toolbox.dtx}{asciidocu}}
\generateFile{toolbox.tex}{f}{\from{toolbox.dtx}{driver}}
%%\generateFile{toolbox.ins.dup}{f}{\from{toolbox.dtx}{insfile}}

\Msg{***************************************************************}
\Msg{*}
\Msg{* To finish the installation you have to move the}
\Msg{* file 'toolbox.sty' into a directory searched by TeX.}
\Msg{*}
\Msg{*}
\Msg{* Run the file toolbox.tex through LaTeX to produce the}
\Msg{* documentation or read the ascii documentation in toolbox.txt}
\Msg{*}
\Msg{*}
\Msg{***************************************************************}
\endbatchfile
%</insfile>
%<*metainfo>
% \fi
\fi
% \iffalse
%</metainfo>
% \fi
\endinput

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "toolbox.tex"
%%% End: 
